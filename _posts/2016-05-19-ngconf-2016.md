---
layout: post
title: "Takeaways from ng-conf 2016"
tags: angularjs
author: Gabe Miller
---

In August 2015 I enrolled in the ng-conf 2016 ticket lottery. Given entry to the was free, I figured why not enter? There are tons of people who are going to try to get in, so it's improbably I'll win a ticket, right?

I was proven wrong when the following March I received an invitation to attend. I was a little hesitant about pulling the trigger at first, but I'm glad to say that I decided to go. Here we come Salt Lake City!

I went to the conference with very little exposure to Angular 2.x and Typescript, but a lot of exposure to Angular 1.x. Most of the talks were based around Angular 2.x. This post is a highly compressed recap of the major topics of the conference:

- [Differences between Angular 1.x and Angular 2.x](#differences-between-angular-1x-and-angular-2x)
- [Angular Universal](#angular-universal)
- [TypeScript](#typescript)
- [Observables and RxJS](#observables-and-rxjs)

And lastly, a [demo angular 2.x application](#demo-angular-2x-application). So let's get started.

# Differences between Angular 1.x and Angular 2.x

Angular 2.x has some major design changes from Angular 1.x. Here are some points on which I'll further elaborate:

- The digest cycle is no more
- Creating web components has been greatly simplified
- Dependency injection works differently
- Interactions with the DOM have been abstracted from the framework

## ZoneJS and the Digest Cycle
Angular 2.x implements a library called zone.js, which can create "execution contexts that persist across async tasks". Angular 2.x uses this functionality for its change detection system as opposed to the digest cycle used in Angular 1.x.

## Learn More

- [Julie Ralph's ng-conf 2016 presentation](https://www.youtube.com/watch?v=DltUEDy7ItY)
- [Zones in Angular 2](http://blog.thoughtram.io/angular/2016/02/01/zones-in-angular-2.html)
- [Zone.js Sourcecode](https://github.com/angular/zone.js)

## Web Components

The Angular 2.x advocates designing your application as a hierarchy of web components. This is similar to the concept of directives in Angular 1.x. You may also be familiar with components as they were backported into Angular 1.5 in order to make a smooth upgrade path from 1.x to 2.x. If you're already using .component and/or web components, this is great news! Here's an example Angular 2.x component, pulled from the documentation website: 

{% highlight typescript %}

import { Component } from '@angular/core';

export class Hero {
  id: number;
  name: string;
}

@Component({
  selector: 'my-app',
  template:`
    <h1>{{title}}</h1>
    <h2>{{hero.name}} details!</h2>
    <div><label>id: </label>{{hero.id}}</div>
    <div>
      <label>name: </label>
      <input [(ngModel)]="hero.name" placeholder="name">
    </div>
    `
})

export class AppComponent {
  title = 'Tour of Heroes';
  hero: Hero = {
    id: 1,
    name: 'Windstorm'
  };
}

{% endhighlight %}

There is a lot going on here. The first thing you probably noticed is that this is not written in JavaScript. It is a language called TypeScript. Read more about TypeScript [here](#typescript). While writing TypeScript isn't required to use Angular 2.x, its development team uses it and recommends using it. With that out of the way, let's look at concepts here that are new to an Angular 1.x developer.

First we're using the `import` keyword to load a function from a different module. In this case we're loading the `Component` function from the `@angular/core` module.

Next we're creating a class called `Hero` with properties `id` and `string`. The `export` keyword means that this class will be able to be imported and used by other classes. 

Then we're using the `Component` function that we imported as a decorator, as indicated by the `@` prefix. An object is passed into this function with a selector and a template. The selector is what you'll put in your markup to create an instance of this component. The template is an in-line multiline string. Backtics are used in ES6 to create multiline strings. You can, and should, put your templates in separate files when writing your own projects. This example is simply squeezing everything into a single file.

Lastly we're exporting the class AppComponent, which is the root component of the demo application. This is sort of like the `ng-app` directive that could bootstrap an Angular 1.x application. Inside of the app component class we just have a couple variables that will be used by the template.

## Dependency injection

### Learn More

- [Dependency Injection in Angular 2](http://blog.thoughtram.io/angular/2015/05/18/dependency-injection-in-angular-2.html)

## DOM Interactions

In Angular 2.x interactions with the DOM have been abstracted at a lower level in the framework. In Angular 1.x the framework relied on being bootstrapped within the context of a website. This is no longer the case. What this means is that Angular 2.x can run anywhere there is a javascript environment. This includes the ability to [pre-render templates on the server](#angular-universal), run as a desktop application inside of [electron](http://electron.atom.io/), or run as a [native application on iOS or Android](https://www.nativescript.org/). It also means that Angular 2.x can run within a web worker. These are all things that were not possible within Angular 1.x.

# Angular Universal

test 

# TypeScript

test 

## Learn More

TypeScript is a language that is a superset of JavaScript. It compiles down to ES5 JavaScript. Or other versions, if so desired. It allows you to use features from ES6(aka ES2015) as well as ES7. It also introduces typing, which allows for fantastic tooling. The typing is completely optional and, when compiles to JavaScript, does not do runtime type checking. Further, if you want to start using types but you don't want to commit to a large refactor yet, you can set all of your variables to the `any` type and the compiler will let them through. In fact, if you don't specify a type on a variable the compiler will assume that it is of type `any` by default.

Let's revisit the example application on Angular's documentation website as an example.

{% highlight typescript %}

export class Hero {
  id: number;
  name: string;
}

export class AppComponent {
  title = 'Tour of Heroes';
  hero: Hero = {
    id: 1,
    name: 'Windstorm'
  };
}

{% endhighlight %}

In this snippet we're creating two classes: `Hero` and `AppComponent`. AppComponent has a variable called `Hero` that is of type `Hero`. That type is created as the class shown above. Also notice that the `Hero` variable has valid `id` and `name` properties, as `1` is a `number` and `'Windstorm'` is a `string`. If these properties did not match the specified types then the TypeScript compiler would complain to you. Also of note, your text editor can be configured to highlight type mismatch errors.

Some other valuable concepts that TypeScript introduces, among many others, are interfaces, inheritance, and generics.

Interfaces are used to create contracts in your code. If a class implements an interface, you have a guarantee that it has specific methods and/or properties on it. It is wonderfully useful to have this guarantee when working with larger codebases. Fatfingered a method name? Accidentally deleted a line? An interface could have easily saved you a debugging headache. You can implement an interface by using the `implements` keyword in a class declaration.

Both classes and interfaces can inherit from other classes or interfaces, respectively. You can use inheritance by using the `extends` keyword in a class or interface declaration.

- [TypeScript Playground](https://www.typescriptlang.org/play/index.html)

# Observables and RxJS

test 

# Demo Angular 2.x Application

test 

